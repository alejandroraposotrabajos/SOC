<#
.SYNOPSIS
  Obtiene un token (API key) desde TheHive y guarda/actualiza .env con THEHIVE_API_KEY

.DESCRIPTION
  Hace POST a /api/user/login con credenciales, extrae el token desde la respuesta y escribe
  o actualiza el archivo .env en la raíz del proyecto con la variable THEHIVE_API_KEY.

.PARAMETER Url
  URL base de TheHive (por defecto http://localhost:9000)

.PARAMETER Username
  Usuario para login (por defecto: admin@thehive.local)

.PARAMETER Password
  Password para login. Si se omite, se pedirá interactivamente de forma segura.

.PARAMETER EnvPath
  Ruta al archivo .env a escribir (por defecto: ../.env relativo al script)

.EXAMPLE
  .\get-thehive-token.ps1 -Url http://localhost:9000 -Username cetiart -Password cetiart

.NOTES
  - No guarda contraseñas en el repo. .env queda en la raíz del proyecto y está en .gitignore.
  - Soporta respuestas JSON con distintas estructuras (token, authToken, data.token, etc.).
#>

param(
    [string]$Url = "http://localhost:9000",
    [string]$Username = "admin@thehive.local",
    [System.Security.SecureString]$Password,
    [string]$EnvPath
)

# Determinar ruta por defecto de .env (raíz del proyecto, asumiendo scripts/ está en raíz)
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$projectDir = Split-Path -Parent $scriptDir
if (-not $EnvPath) { $EnvPath = Join-Path $projectDir ".env" }

if (-not $Password) {
    Write-Host "Introduce la contraseña para el usuario ${Username}:" -ForegroundColor Yellow
    $Password = Read-Host -AsSecureString
}

$loginUrl = "$Url/api/user/login"
# Convert SecureString password to plain string for the JSON payload
$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password)
$plainPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto($ptr)
[Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr) | Out-Null

$body = @{ username = $Username; password = $plainPassword } | ConvertTo-Json

Write-Host "Intentando login en $loginUrl con usuario $Username..." -ForegroundColor Cyan
try {
    # Usamos Invoke-RestMethod para recibir JSON ya parseado
    $response = Invoke-RestMethod -Method Post -Uri $loginUrl -Body $body -ContentType 'application/json' -ErrorAction Stop
} catch {
    Write-Error "Login fallido: $($_.Exception.Message)"
    exit 1
}

# Intentar extraer el token de varias rutas posibles
$token = $null
if ($null -ne $response) {
    if ($response -is [System.Collections.IDictionary]) {
        if ($response.ContainsKey('token')) { $token = $response.token }
        elseif ($response.ContainsKey('authToken')) { $token = $response.authToken }
        elseif ($response.ContainsKey('data') -and $response.data -and $response.data.token) { $token = $response.data.token }
        elseif ($response.ContainsKey('data') -and $response.data -and $response.data.authToken) { $token = $response.data.authToken }
    }

    # Si es un array con elementos que contienen token
    if (-not $token) {
        try {
            foreach ($item in $response) {
                if ($item -is [System.Collections.IDictionary]) {
                    if ($item.ContainsKey('token')) { $token = $item.token; break }
                    if ($item.ContainsKey('authToken')) { $token = $item.authToken; break }
                }
            }
        } catch { }
    }
}

# Fallback: intentar parsear string si Invoke-RestMethod devolvió texto
if (-not $token) {
    $raw = $response | Out-String
    if ($raw -match '"token"\s*:\s*"([^"]+)"') { $token = $matches[1] }
    elseif ($raw -match '"authToken"\s*:\s*"([^"]+)"') { $token = $matches[1] }
}

if (-not $token) {
    Write-Error "No se pudo extraer un token desde la respuesta de TheHive. Respuesta completa:" 
    Write-Output $response | ConvertTo-Json -Depth 5
    exit 2
}

Write-Host "Token obtenido correctamente." -ForegroundColor Green

# Escribir o actualizar .env
try {
    $backupMade = $false
    if (Test-Path $EnvPath) {
        $timestamp = (Get-Date).ToString('yyyyMMddHHmmss')
        $bak = "$EnvPath.bak.$timestamp"
        Copy-Item -Path $EnvPath -Destination $bak -Force
        Write-Host "Backup del .env existente creado: $bak" -ForegroundColor DarkCyan
        $backupMade = $true
        # Leer líneas y reemplazar si existe THEHIVE_API_KEY
        $lines = Get-Content $EnvPath -ErrorAction Stop
        $found = $false
        for ($i=0; $i -lt $lines.Length; $i++) {
            if ($lines[$i] -match '^THEHIVE_API_KEY=') {
                $lines[$i] = "THEHIVE_API_KEY=$token"
                $found = $true
                break
            }
        }
        if (-not $found) { $lines += "THEHIVE_API_KEY=$token" }
        $lines | Out-File -FilePath $EnvPath -Encoding ASCII -Force
    } else {
        # Crear nuevo .env
        "# Generated by get-thehive-token.ps1" | Out-File -FilePath $EnvPath -Encoding ASCII -Force
        "THEHIVE_API_KEY=$token" | Out-File -FilePath $EnvPath -Encoding ASCII -Append
    }

    Write-Host ".env actualizado en: $EnvPath" -ForegroundColor Green
    if ($backupMade) { Write-Host "(Se creó backup previo)" -ForegroundColor DarkCyan }
} catch {
    Write-Error "Fallo al crear/actualizar .env: $($_.Exception.Message)"
    exit 3
}

Write-Host "Hecho. Reinicia tus contenedores (docker-compose down && docker-compose up -d) para que cambien las variables de entorno." -ForegroundColor Yellow
